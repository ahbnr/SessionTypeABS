package de.ahbnr.sessiontypeabs.dynamicenforcement.codegen

import de.ahbnr.sessiontypeabs.dynamicenforcement.automata.SessionAutomaton
import org.abs_models.frontend.ast.*

/**
 * Most ABS code generated by the functions in this package which deal with the implementation of Session Automata
 * depend on the ABS module SessionTypeABS.SchedulerHelpers, which can be found in src/main/resources/schedulerlib.abs
 *
 * This file provides functions to easily build AST nodes to access the contents of the module.
 */

const val schedulerLibModuleName = "SessionTypeABS.SchedulerHelpers"

// Types
fun registerT() =
    UnresolvedTypeUse(
        "$schedulerLibModuleName.Register",
        List() //Annotations
    )

// Common parameters
fun queueParameter() =
    ParamDecl(
        schedulerFunQueueParamIdentifier,
        listT(processT()),
        List() // Annotations
    )

fun stateParameter() =
    ParamDecl(
        stateFieldIdentifier,
        intT(),
        List() // Annotations
    )

fun registerParameters(automaton: SessionAutomaton) =
    automaton
        .registerIdentifiers()
        .map{registerName ->
            ParamDecl(
                registerName,
                registerT(),
                List() // Annotations
            )
        }
        .toTypedArray()


// Functions

fun orElseMaybe(maybeValue: PureExp, elseValue: PureExp) =
    FnApp(
        "$schedulerLibModuleName.orElseMaybe",
        List(
            maybeValue,
            elseValue
        )
    )

fun matchNamesOrRegisters(whitelist: Set<String>, registers: Set<Int>, allRegisters: Set<Int>) =
    FnApp(
        "$schedulerLibModuleName.matchNamesOrRegisters",
        List(
            setC(*whitelist.map { methodName -> StringLiteral(methodName) }.toTypedArray()),
            setC(*registers.map { register -> VarUse(registerIdentifier(register)) }.toTypedArray()),
            setC(*allRegisters.map { register -> VarUse(registerIdentifier(register)) }.toTypedArray()),
            VarUse(schedulerFunQueueParamIdentifier)
        )
    )

fun applyProtocol(protocol: ParFnAppParam, whitelist: Set<String>, queue: PureExp) =
    callHigherOrderFun(
        "$schedulerLibModuleName.applyProtocol",
        protocol,
        setC(*whitelist.map { methodName -> StringLiteral(methodName) }.toTypedArray()),
        queue
    )

// Other stuff

fun purePrintLn(output: PureExp, returnExp: PureExp, uniqueId: Int = 0) =
    LetExp( // Hack to call println in pure expression
        ParamDecl("printRet$uniqueId", unitT(), List()),
        callFun("println", output),
        returnExp
    )
